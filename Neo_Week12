//Headerfile
#pragma once
#include<iostream>
#include<string>
using namespace std;

template<class T>
class SmarterArray
{
private:
	T *A;
	int size;

public:
	//Constructors
	SmarterArray();
	SmarterArray(const T*A,const int &size);
	SmarterArray(const SmarterArray<T> &L);//Deep Copy

	//Assignment Operator
	SmarterArray<T>& operator=(const SmarterArray<T>&);

	//Destructor
	~SmarterArray();

	//Getters,setters,operators,and others
	int getSize() const;
	T& operator[](const int &index)const;
	int find(const T&e)const;
	void append(const T &e);
	bool remove(const T&e);
	SmarterArray<T> operator - (const SmarterArray<T> &L)const;

	template<class T>
	friend ostream& operator<<(ostream &outputStream, const SmarterArray<T> &L);
	
	
};

==================================================
//impletation
#pragma once
#include "SmarterArray.h"

template<class T>
SmarterArray<T>::SmarterArray()
{
	this->size = 0;
}

template<class T>
SmarterArray<T>::SmarterArray(const T*A,const int &size)
{
	this->size = size;
	if(this->getSize()>0)
	{
		this->A = new T [this->getSize()];
		for(int i = 0;i<this->getSize();i++)
			this->A[i] = A[i];
	}
}

template<class T>
SmarterArray<T>::SmarterArray(const SmarterArray<T> &L)//Copy constructor
{
	this->size = L.getSize();
	if(this->getSize()>0)
	{
		this->A = new T[this->getSize()];
		for(int i = 0;i<this->getSize();i++)
			this->A[i] = L[i];
	}
}

template<class T>
SmarterArray<T>& SmarterArray<T>::operator=(const SmarterArray<T>&L)
{
	if(this==&L)//same to if(&(*this)==&L)
		return *this;
	this->~SmarterArray();
	this->size = L.getSize();
	if(this->getSize() > 0)
	{
		this->A = new T[this->getSize()];
		for(int i = 0;i<this->getSize();i++)
			this->A[i] = L[i];
	}
	return *this;
}

template<class T>
SmarterArray<T>::~SmarterArray()
{
	if(this->getSize()>0)
	{
		delete[] this->A;
		this->size = 0;
	}
}

template<class T>
int SmarterArray<T>::getSize() const
{
	return this->size;
}

template<class T>
T& SmarterArray<T>:: operator[](const int &index)const
{
	if(index>=0&&index < this->getSize())
		return this->A[index];
	else
	{
		cout<<"error! out of bound!\n";
		system("exit");
		return this->A[index];
	}
}

template<class T>
int SmarterArray<T>::find(const T &e) const
{
	for(int i = 0;i<this->getSize();i++)
		if(this->A[i]==e)
			return i;
	return -1;
}

template<class T>
void SmarterArray<T>::append(const T &e)
{
		T*temp = new T [this->getSize()+1];
		for(int i = 0;i<this->getSize();i++)
			temp[i] = this->A[i];
		temp[this->getSize()] = e;
		if(this->getSize()>0)
			delete[] this->A;
		this->A = temp;
		this->size += 1;
}

template<class T>
bool SmarterArray<T>::remove(const T&e)
{
	int index = this->find(e);
	if(index == -1)
		return false;
	else
	{
		T*temp = new T[this->getSize()-1];
		for(int i = 0;i<index;i++)
			temp[i] = this->A[i];
		for(int i = index+1;i<this->getSize();i++)
			temp[i-1] = this->A[i];
		if(this->getSize()>0)
			delete[]this->A;
		this->A = temp;
		this->size -= 1;
		return true;
	}
}

template<class T>
SmarterArray<T> SmarterArray<T>::operator-(const SmarterArray<T> &L)const
{
	SmarterArray<T>A;
	for(int i = 0;i<this->getSize();i++)
	{
		int index  = L.find(this->A[i]);
		if(index == -1)
			A.append(this->A[i]);
	}
	return A;
}

template<class T>
ostream& operator<<(ostream &outputStream, const SmarterArray<T> &L)
{
	outputStream<<" [ ";
	for(int i = 0;i<L.getSize()-1;i++)
		outputStream << L[i]<<" , ";
	if(L.getSize()>0)
		outputStream<<L[L.getSize()-1];
	outputStream<<" ] ";
	return outputStream;
}

=============================================
//main
#include"SmarterArray.h"
#include"SmarterArray.cpp"
#include<ctime>
int main()
{
	SmarterArray<int>A1;
	double x[3] = {2.4,1.2,5.8};
	SmarterArray<double> A2(x,3);
	SmarterArray<string>A3;

	srand(time(0));
	for(int i = 0;i<10;i++)
	{
		if(rand()%2 == 0)
			A1.append(rand()%21+5);
		else
		{
			int random = rand()%5;
			A3.append(random == 0?"Paul":
			(random == 1 ?"Jannet":
			(random == 2 ?"Kevin":
			(random == 3 ?"Sara":"CMPT"))));
		}
	}

	cout<<"The SmarterArray obj A1 is "<<A1 <<endl;
	cout<<"The SmarterArray obj A2 is "<<A2 <<endl;
	cout<<"The SmarterArray obj A3 is "<<A3 <<endl;


}


/*
#include<iostream>
#include<cstdlib>
#include<ctime>
#include<string>
using namespace std;
template<class T>//this is a template function
int sequentialSearch(const T*A,const int size,const T&searchValue)
{
	for(int i = 0;i<size;i++)
	{
		if(A[i]==searchValue)
			return i;
		else
			continue;
	}
	return -1;

}

template<class T>
T getMaximumElement(const T*A,const int size)
{
	T m = A[0];
	for(int i  =1;i<size;i++)
	{
		if(A[i]>m)
			m =A[i];
	}
	return m;
}
int main()
{
	const int size = 10;
	int *A1 = new int[size];
	double *A2 = new double[size];
	string *A3 = new string[size];

	srand(time(0));

	for (int i = 0;i<size;i++)
	{
		A1[i] = rand()%21+5;
		A2[i] = ((1.0*rand())/RAND_MAX)*15.0+5.0;
		int random  =rand()%5;
		A3[i] = (random == 0?"Paul":
			(random == 1 ?"Jannet":
			(random == 2 ?"Kevin":
			(random == 3 ?"Sara":"CMPT"))));
	}
	cout<<"Here r the arrays created..."<<endl<<endl;
	cout<<"Array A1\tArray A2\tArray A3"<<endl;
	cout<<"=========\t========\t========="<<endl;
	for(int i = 0;i<size;i++)
		cout<<A1[i]<<"\t\t"<<A2[i]<<"\t\t"<<A3[i]<<endl;
	cout<<endl;

	int s1 = rand()%21+5;
	double s2 = A2[rand()%size];
	string s3 = "Sara";
	int ans1 = sequentialSearch(A1,size,s1);
	int ans2 = sequentialSearch(A2,size,s2);
	int ans3 = sequentialSearch(A3,size,s3);

	if(ans1 == -1)
		cout<<s1<<" is not found in the array A1 "<<endl;
	else
		cout<<s1<<" is found in the Array A1 at index "<<ans1<<endl;
	if(ans2 == -1)
		cout<<s2<<" is not found in the array A2 "<<endl;
	else
		cout<<s2<<" is found in the Array A2 at index "<<ans2<<endl;
	if(ans3 == -1)
		cout<<s3<<" is not found in the array A3 "<<endl;
	else
		cout<<s3<<" is found in the Array A3 at index "<<ans3<<endl;
	//system("Pause");
	cout<<"Max of A1 is "<<getMaximumElement(A1,size)<<endl;
	cout<<"Max of A2 is "<<getMaximumElement(A2,size)<<endl;
	cout<<"Max of A3 is "<<getMaximumElement(A3,size)<<endl;

}
*/

///CopyConstructor needs smartArray<T> as parameter
///Must include .cpp file




