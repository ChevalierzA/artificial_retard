#pragma once
#include<iostream>
using namespace std;
///This is the mainBase including shape,rectangle,circle&traingle

class Shape
{
public:
	virtual float getArea()const = 0;//pure virtual function.
	virtual void printName()const
	{
		cout<<"Shape:I don't know my shape."<<endl;
	}
};
class Rectangle:public Shape
{
private:
	float width,height;
public:
	Rectangle():width(0),height(0){}
	Rectangle(float w,float h):width(w),height(h){}
	virtual float getArea()const{return width*height;}
	virtual void printName()const{cout<<"Shape:Rectangle"<<endl;}
};
class Traingle : public Shape
{
private:
		float side1,side2,side3;
public:
	Traingle():side1(1.0),side2(1.0),side3(sqrt(2.0)){}
	Traingle(float s1,float s2,float s3):side1(s1),side2(s2),side3(s3){}
	virtual float getArea()const
	{
		float s = (side1+side2+side3)/2.0;
		return sqrt(s*(s-side1)*(s-side2)*(s-side3));
	}
	virtual void printName()const{cout<<"Shape:Traingle"<<endl;}
};
class Circle:public Shape
{
private:
	float radius;
public:
	Circle():radius(1.0){}
	Circle(float r):radius(r){}
	virtual float getArea()const{return 3.14*radius*radius;}
	virtual void printName()const {cout<<"Shape:Circle"<<endl;}
};
typedef Shape* ShapePtr;

///////////////////////////////////////

#include"Shape.h"
int main()
{
	//Shape s; 
	Rectangle r(4.0,5.0);
	Traingle t;
	Circle c(2.0);
	/*
	s.printName();
	cout<<"\tArea = "<<s.getArea()<<endl<<endl;

	r.printName();
	cout<<"\tArea = "<<r.getArea()<<endl<<endl;

	t.printName();
	cout<<"\tArea = "<<t.getArea()<<endl<<endl;

	c.printName();
	cout<<"\tArea = "<<c.getArea()<<endl<<endl;
	*/
	const int size = 5;
	ShapePtr *myShape = new ShapePtr[size];
	myShape[0] = new Rectangle(4.0,5.0);
	myShape[1] = new Traingle();
	myShape[2] = new Circle(2.0);
	myShape[3] = new Traingle();
	myShape[4] = new Circle(2.0);
	for(int i = 0;i<size;i++)
	{
		myShape[i]->printName();
		cout<<"\tArea = "<<myShape[i]->getArea()<<endl<<endl;
	}
	cout<<endl;
	getchar();
}

///Polymorphism:incapsulation,Avoid automatic casting
///Vitural has to be redefined in all its derived classes
///Must use a pointer
///all interfaces r abstract functions, vice not
